---
title: "Curso Intensivo sobre o Sistema Quarto, Linguagem R e o tidyverse"
subtitle: "Econometria Aplicada à Finanças"
lang: pt-BR
author: "Seu Nome"
date: 2025-08-25
format: 
  html:
    theme: flatly
    embed-resources: true
    toc: true
    number-sections: true
execute:
  echo: true
  message: false
  warning: false
---


```{r}
#| label: setup
#| echo: false

# digitos exibidos
options(digits = 5, scipen = 999)

# Carrega os pacotes usados
library(here)       # para trabalhar com caminhos relativos
library(tidyverse)  # metapacote para ciência de dados 
```



# Introdução ao Sistema Quarto

Antes de escrever código em R, é preciso entender o ambiente em que os 
relatórios serão produzidos. **Quarto** é um sistema de publicação que 
integra texto, código e figuras em um documento unificado. Ele permite 
gerar relatórios científicos, apresentações, slides e dashboards de forma 
reprodutível. 

As principais características incluem:

- **Integração de texto e código**: texto em Markdown e código
executável em R, Python ou Julia.  

- **Reprodutibilidade**: o documento armazena o código que gerou 
tabelas e gráficos, tornando  o relatório verificável.  

- **Diversos formatos de saída**: um único arquivo `.qmd` pode ser 
renderizado para HTML, PDF ou Word.  

- **Integração com Git**: ideal para versionamento e colaboração.


## Estrutura de um documento Quarto

Um documento Quarto é composto por três partes:

1. **Cabeçalho YAML**: delimita metadados como título, autor, data 
e formato de saída.  

2. **Corpo em Markdown**: texto dividido em seções com 
títulos (`#`, `##`, `###`, etc.).  

3. **Células/Blocos de código (chunks)**: trechos de código R 
(ou outra linguagem) que são executados ao renderizar o documento.


Exemplo de cabeçalho mínimo:

```yaml
---
title: "Meu Primeiro Relatório"
author: "Seu Nome"
format: html
---
```


Os atalhos de teclado a seguir são importantes para aumentar 
sua produtividade e eficiência ao usar o sistema Quarto com o RStudio 
(Windows):

- Inserir o operadord de atribuicão `<-`: `Alt + -` (`=` funciona, mas não 
  é recomendado)
- Inserir bloco de código: `Ctrl + Alt + I`
- Executar bloco de código: `Ctrl + Shift + Enter`
- Renderizar documento: `Ctrl + Shift + K`




# Por que aprender R?

**R** é uma linguagem de programação e ambiente estatístico amplamente 
utilizado em ciência de dados, finanças, estatística e pesquisa aplicada.  
Com R podemos importar, limpar, transformar, visualizar e modelar dados.  
Grande parte desse poder vem do conjunto de pacotes chamado **tidyverse**.

Ele inclui pacotes como:

- **readr** (importação de arquivos de dados (csv))
- **dplyr** (transformação de dados), 
- **tidyr** (organização de dados), 
- **ggplot2** (visualização),

e que foram desenvolvidos para trabalhar juntos de maneira coerente.



# Operadores básicos

Esta seção apresenta operadores, tipos de dados, funções matemáticas 
e estatísticas básicas.

Alguns dos principais operadores da linguagem R estão exibidos na @tbl-1.


| Operador(es)            | Descrição                     | Exemplo em R    |
|-------------------------|-------------------------------|-----------------|
| `<-`                  | Atribuição de valores           | `x <- 5`        |
| `+`                   | Adição                          | `2 + 3`         |
| `-`                   | Subtração                       | `7 - 4`         |
| `*`                   | Multiplicação                   | `6 * 2`         |
| `/`                   | Divisão                         | `10 / 2`        |
| `^`                   | Potenciação                     | `3 ^ 2`         |
| `<`, `<=`, `>`, `>=`  | Comparações relacionais         | `4 > 2`         |
| `==`, `!=`            | Igualdade e diferença           | `5 == 5`        |
| `&`, `|`, `!`         | Operadores lógicos (E, OU, NÃO) | `TRUE & FALSE`  |
: Operadores básicos {#tbl-1}


Seguem alguns exemplos de uso dos operadores:

```{r}
# atribuição de valor
x <- 10

# exibe o valor de x
x
```

```{r}
# adição
y <- x + 5

# exibe o resultado
y
```


```{r}
# subtração
z <- y - 3

# exibe o resultado
print(z)
```


```{r}
# multiplicação
w <- z * 2
w
```


```{r}
# divisão
v <- w / 4
v
```

```{r}
# potenciação
u <- v^2

# exibe o resultado
u
```


```{r}
# comparação: verifica se x é maior que 5
x > 5
```


```{r}
# igualdade: verifica se x é igual a 10
x == 10
```


```{r}
# operador lógico: verifica se x é maior que 5 e menor que 15 
x > 5 & x < 15
```


```{r}
# operador lógico: verifica se x é maior que 5 ou menor que 0
x > 5 | x < 0
```


```{r}
# exibe x
x

# operador lógico: negação de uma condição
! (x > 5)
```




# Tipos atômicos de dados em R

Os principais tipos atômicos de dados em R estão listados na @tbl-2.


| Tipo        | Classe      | Descrição        |
| ----------- | ----------- | ---------------- |
| `double`    | `numeric`   | valores reais    |
| `integer`   | `numeric`   | valores inteiros |
| `character` | `character` | texto            |
| `logical`   | `logical`   | verdadeiro/falso |
: Tipos básicos {#tbl-2}


Exemplos de criação e exibição de variáveis (ou objetos):

```{r}
# tipo  double
x <- 1.5 # valor real
```


```{r}
# verifica o tipo e a classe
typeof(x)
class(x)
```


```{r}
# tipo integer
y <- 10L    
```


```{r} 
# verifica o tipo e a classe
typeof(y)
class(y)
```


```{r}
# tipo character
z <- "administração"
```


```{r}
# verifica o tipo e a classe
typeof(z)
class(z)
```


```{r}
# tipo logical
w <- TRUE   
```


```{r}
# verifica o tipo e a classe
typeof(w)
class(w)
```




# Estruturas de dados

## Vetores

Um **vetor** é a estrutura unidimensional mais simples em R. Todos os 
elementos de um vetor devem ser do mesmo tipo (numérico, lógico ou texto).  
Você cria vetores com a função `c()` e pode aplicar funções a todo o conjunto:

```{r}
# custos de projetos em mil reais
custos <- c(12, 15, 9, 14)  

# custo médio
mean(custos)                
```




## Funções matemáticas e estatísticas vetoriais

R possui diversas funções que facilitam cálculos matemáticos e estatísticos 
diretamente aplicáveis a vetores ou colunas de data frames ou tibbles, 
vejamos algumas delas. 

Vamos criar um vetor numérico para exemplificar as funções:

```{r}
# cria um vetor numérico
numerico <- c(1, 3, 3.5, 4, 5, 6.5, 7, 8.5, 9, 10)

# exibe o vetor
numerico
```


A função `length()` retorna o número de elementos (tamanho) de um vetor:

```{r}
length(numerico)
```

A função `sum()` calcula a soma dos elementos de um vetor, ou seja:

$$
\sum_{i=1}^n x_i = x_1 + x_2 + x_3 + \ldots + x_n
$$

```{r}
sum(numerico)
```


A função `cumsum()` calcula a soma acumulada dos elementos de um vetor, 
ou seja:

$$
\text{cumsum}(x) = \left( x_1, x_1 + x_2, x_1 + x_2 + x_3, \ldots, \sum_{i=1}^{n} x_i \right)
$$

```{r}
# calcula a soma acumulada
cumsum(numerico)
```

A função `prod()` calcula o produto dos elementos de um vetor, ou seja:

$$
\prod_{i=1}^n x_i = x_1 \times x_2 \times x_3 \times \ldots \times x_n
$$

```{r}
# calcula o produto dos elementos
prod(numerico)
```

A função `cumprod()` calcula o produto acumulado dos elementos de um vetor, 
ou seja:

$$
\text{cumprod}(x) = \left( x_1, x_1 \times x_2, x_1 \times x_2 \times x_3, \ldots, \prod_{i=1}^{n} x_i \right)
$$

```{r}
# calcula o produtoacumulado
cumprod(numerico)
```

```{r}
# calcula o logaritmo natural dos elementos
log(numerico)
```


```{r}
# logaritmo na base 10
log10(numerico)
```


```{r}
# calcula a função exponencial dos elementos
exp(numerico)
```


```{r}
# calcula a média amostral
mean(numerico)
```


```{r}
# calcula a mediana amostral
median(numerico)
```


```{r} 
# calcula os quartis
quantile(x, probs = c(0, 0.25, 0.5, 0.75, 1))
```


```{r}
# calcula os decis
quantile(x, probs = seq(0, 1, 0.1))
```


```{r}
# calcula os percentis
quantile(x, probs = seq(0, 1, 0.01))
```


```{r}
# calcula a variância amostral
var(numerico)
```


```{r}
# calcula o desvio-padrão amostral
sd(numerico)
```


```{r}
# calcula o valor mínimo
min(numerico)
```


```{r}
# calcula o valor máximo
max(numerico)
```




## Matrizes

Matrizes são estruturas bidimensionais que organizam elementos homogêneos 
em linhas e colunas. Em análises estatísticas, econométricas e métodos 
numéricos, matrizes desempenham um papel crítico, especialmente devido à 
eficiência computacional das operações matriciais.

Características Fundamentais:

- **Homogeneidade**: Todos os elementos têm o mesmo tipo.
- **Bidimensionalidade**: Estrutura formada por linhas e colunas.
- **Indexação**: Elementos acessados por `[linha, coluna]`.
- **Operações otimizadas**: Eficientes para cálculos matriciais.


### Criação de Matrizes

A função para criar matrizes é `matrix()`, cuja forma geral é:

```r
matrix(data, nrow, ncol, byrow = FALSE)
```

Os principais argumentos são:

- `data`: vetor de elementos que serão colocados na matriz. Se o número 
de elementos não corresponder exatamente ao número total de posições da 
matriz (`nrow * ncol`), R reciclará os valores, emitindo um aviso.

- `nrow`: número de linhas da matriz.

- `ncol`: número de colunas da matriz.

- `byrow`: define a ordem de preenchimento:

  - `FALSE` *(padrão)*: preenchimento por **colunas** (primeiro preenche 
  toda a 1ª coluna, depois a 2ª, e assim por diante).
  
  - `TRUE`: preenchimento por **linhas** (primeiro preenche toda a 1ª linha, 
  depois a 2ª, e assim por diante).

**Observação**: É suficiente indicar apenas `nrow` ou `ncol` — R calculará 
a outra dimensão automaticamente a partir do comprimento do vetor `data`.

**Exemplo 1** Criando uma matriz especificando `nrow`

Neste caso, como `byrow = FALSE` (padrão), o preenchimento ocorre 
**por colunas**.

```{r}
# Cria matriz 3 x 3, preenchida por colunas (padrão)
A <- matrix(c(2, 1, 2,  # 1ª coluna
              1, 4, 1,  # 2ª coluna
              3, 2, 5), # 3ª coluna
            nrow = 3)

# exibe a matriz
A
```


**Exemplo 2** Cria uma matriz especificando `ncol`

Ao indicar `ncol`, a quantidade de linhas é determinada automaticamente.

```{r}
# Cria matriz com 3 colunas, preenchida por colunas (default)
B <- matrix(1:9, ncol = 3)

# exibe a matriz
B
```



**Exemplo 3** Cria uma matriz preenchendo por linhas

O argumento `byrow = TRUE` altera a ordem de preenchimento.

```{r}
# Matriz 3 x 3, preenchida por linhas
C <- matrix(c(4, 2, 1,  # 1ª linha
              3, 5, 2,  # 2ª linha
              1, 2, 6), # 3ª linha
            ncol = 3,
            byrow = TRUE)
# exibe a matriz
C
```



| Argumentos usados          | Ordem de preenchimento |
| -------------------------- | ---------------------- |
| `byrow = FALSE` *(padrão)* | Por colunas            |
| `byrow = TRUE`             | Por linhas             |
: Resumo - Criação de Matrizes {#tbl-3}




## Álgebra Matricial

A álgebra matricial é fundamental em econometria e a linguagem R oferece 
operações matriciais eficientes, vejamos alguns exemplos:

Vamos criar as seguintes matrizes:

```{r}
# Cria uma matriz 2x3 preenchendo por colunas (padrão)
A <- matrix(c(1, 2, 3, 4, 5, 6), nrow = 2, ncol = 3)
A
```


```{r}
# Cria uma matriz 3x2 preenchidas por colunas 
B <- matrix(c(2, 4, 1, 3, 5, 2), nrow = 2, ncol = 3)
B
```


```{r}
# cria uma matriz 2x2 preenchida por colunas
C <- matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2)
C
```

Podemos verificar a dimensão de uma matriz com a função `dim()`.

```{r}
# dimensões da matriz A
dim(A)    
```

```{r}
# dimensões da matriz B
dim(B)    
```


```{r}
# dimensões da matriz C
dim(C)    
```

Também podemos visualizar o núnmero de linhas e colunas de 
usando as funções `nrow()` e `ncol()`:


```{R}
# Número de linhas
nrow(A)   
```


```{r}
# Número de colunas
ncol(A)  
```


### Operações Básicas


```{r}
# Soma e subtração (matrizes devem ter mesma dimensão)
A + B  # Soma elemento por elemento
```


```{r}
A - B  # Subtração elemento por elemento
```


```{r}
# Multiplicação por escalar (elemento por elemento)
2 * A
```


```{r}
# Multiplicação matricial elemento por elemento 
A * B  # Cada elemento A[i,j] * B[i,j]
```


```{r}
# cria uma matriz 3 x 2
D <- matrix(c(1, 2, 3, 4, 5, 6), nrow = 3, ncol = 2)  
# A (2 x 3) * D (3 x 2) = resultado (2 x 2)
resultado <- A %*% D  
resultado
```


Podemos calcular a transposta de uma matriz com a função `t()`:

```{r}
# Transposta: converte linhas em colunas
A_transposta <- t(A)
A_transposta
```

```{r}
dim(A)           # Original: 2x3
```

```{r}
dim(A_transposta) # Transposta: 3x2
```


A função `det()` calcula o determinante de uma matriz quadrada:

```{r}
# Determinante (apenas para matrizes quadradas)
det_C <- det(C)
det_C
```

A matriz inversa pode ser calculada com a função `solve()`:

```{r}
# Inversa de uma matriz (apenas se determinante ≠ 0)
C_inv <- solve(C)
C_inv
```


```{r}
# Verificação: C * C^(-1) deve resultar na matriz identidade
verificacao <- C %*% C_inv
round(verificacao, 10)  # Arredondando para evitar erros de precisão
``` 




## Data frames

Uma **data frame** é uma estrutura bidimensional similar a uma planilha: 
linhas representam observações e colunas representam variáveis.  

Diferentes colunas podem ter tipos de dados diferentes, mas dentro de 
cada coluna o tipo deve ser homogêneo.  

Características principais de uma data frame:

- **Organização em linhas e colunas**: cada coluna representa uma variável 
e cada linha representa uma observação.

- **Tipos de dados heterogêneos**: diferentes colunas podem conter tipos 
distintos (numéricos, caracteres, lógicos, fatores etc.), mas dentro de 
cada coluna os elementos devem ser do mesmo tipo.

- **Compatibilidade com funções estatísticas e gráficas**: a maioria das 
funções de análise em R aceita data frames como entrada.

- **Rótulos de linhas e colunas**: colunas têm nomes (`colnames`), e 
opcionalmente linhas podem ter nomes (`rownames`).


A função básica para criar uma data frame é `data.frame()`:

```{r}
# cria um data frame simples
df <- data.frame(
  nome   = c("Ana", "Bruno", "Carla"),
  idade  = c(23, 35, 29),
  ativo  = c(TRUE, FALSE, TRUE)
)

df
```


Podemos obter informações sobre a estrutura de uma data frame usando funções internas
como:

```{r}
# função que exibe a estrutura detalhada de um objeto
str(df)       
```

```{r}
# função que exibe os nomes das colunas/variáveis
names(df)     
```

```{r}
# função que exibe o número de linhas
nrow(df)     
```

```{r}
# função que exibe o número de colunas
ncol(df)      
```



Podemos indexar (acessar ou selecionar) diferentes elementos de uma data frame 
usando as seguintes sintaxes:

```{r}
# seleciona uma coluna pelo nome
df$idade      
```


```{r}
# seleciona a segunda coluna pelo índice
df[, 2]       
```


```{r}
# seleciona uma linha pelo índice
df[2, ]      
```


```{r}
# seleciona um elemento específico (linha, coluna)
df[1, 3]      # linha 1, coluna 3
```


Boas práticas com data frames:

- Sempre nomear colunas/variáveis de forma clara e sem espaços.
- Manter consistência de tipos em cada coluna.
- Usar o pacote `dplyr` para manipulação mais legível e eficiente.



## Tibbles

Uma **tibble** é uma versão moderna do data frame, fornecida pelo 
pacote `tibble`. Ela melhora a impressão no console e se integra 
ao tidyverse.  

Para criar uma tibble, use `tibble()` ou `as_tibble()`:

```{r}
tb <- tibble(
  nome   = c("Ana", "Bruno", "Carla"),
  idade  = c(23, 35, 29),
  ativo  = c(TRUE, FALSE, TRUE)
)

tb
```




# Importação de dados com readr e here

Até agora trabalhamos com dados digitados manualmente ou embutidos 
em R. Na prática, é importante saber importar corretamente arquivos de 
dados externos (csv, xlsx, etc.).  

A função `read_csv()` do pacote **readr** (um dos pacotes do tidyverse) 
lê arquivos delimitados por vírgulas, enquanto a função `read_csv2()` lê 
arquivos separados por ponto e vírgula (típico no Brasil).  

Essas funções têm sintaxe unificada: o primeiro argumento é o caminho 
do arquivo.  

Para organizar caminhos de arquivos de forma reproduzível use 
o pacote **here**. A função `here()` do pacote her cria caminhos relativos 
a partir do diretório raiz do projeto.  

Para importar o arquivo `dados/brutos/dados-simulados.csv` podemos 
utilizar a seguinte sintaxe:

```{r}
# defina o caminho relativo do arquivo 
caminho_csv <- here::here("dados/brutos/dados_simulados.csv")

# importa o arquivo csv
dados <- readr::read_csv(caminho_csv)

# estrutura dos dados importados
dplyr::glimpse(dados)
```




# Introdução ao pacote dplyr

O pacote **`dplyr`** é parte do **tidyverse** e fornece uma gramática 
intuitiva para manipulação de dados. Ele é amplamente utilizado para 
transformar e resumir data frames e tibbles de forma eficiente e 
legível.

## Principais funções do dplyr

| Função         | Descrição                                      |
|----------------|------------------------------------------------|
| `filter()`     | Filtra linhas com base em condições            |
| `slice()`      | Seleciona linhas específicas (pelo índice)     |
| `select()`     | Seleciona colunas específicas                  |
| `mutate()`     | Cria ou modifica colunas                       |
| `summarize()`  | Resumir dados agregando colunas                |
| `arrange()`    | Ordena linhas com base em colunas              |
| `group_by()`   | Agrupa dados por uma ou mais colunas           |
| `join`          | Combina data frames com base em chaves        |


O pacote **dplyr** fornece funções fáceis de entender e poderosas para 
manipular dados.  Vamos explorar algumas funções fundamentais utilizando o 
conjunto `dados`.


## O operador pipe %>%

O operador pipe (%>%) envia o resultado de uma operação para a próxima.
Isso evita criar objetos intermediários e torna o código mais legível.

```{r}
# Sem pipe (menos legível)
arrange(filter(dados, setor == "Tecnologia"), desc(lucro_liquido))

# Com pipe (mais legível)
dados %>% 
  filter(setor == "Tecnologia") %>% 
  arrange(desc(lucro_liquido))
```


## Função `filter()

A função`filter()` filtra apenas as linhas que satisfazem os 
critérios lógicos definidos

```{r}
# Filtra apenas empresas do setor Tecnologia
dados %>% 
  filter(setor == "Tecnologia")
```



## Função slice()

A função `slice()` filtra linhas específicas pela posição que 
ocupam.


```{r}
# Seleciona as 3 primeiras empresas da tabela
dados %>% 
  slice(1:3)
```


## Função select()

A função `select()` permite selecionar apenas as variáveis de interesse.

```{r}
# Seleciona apenas empresa, setor e lucro líquido
dados %>% 
  select(empresa, setor, lucro_liquido)
```


## Função mutate()

A função `mutate()` cria novas variáveis ou modifica variáveis existentes.

```{r}
# Cria coluna margem de lucro = lucro / receita
dados %>% 
  mutate(margem_lucro = lucro_liquido / receita_liquida)
```


## Função group_by() e summarize()

A função `group_by()` agrupa observações e, em conjunto com `summarize()`, 
permite análises (i.e, calcular estatísticas) por grupo.

```{r}
# Lucro médio por setor
dados %>% 
  group_by(setor) %>% 
  summarize(lucro_medio = mean(lucro_liquido, na.rm = TRUE))
```



## arrange(): Ordenar linhas

A função `arrange()` ordena as linhas de uma data frame ou tibble com base 
em uma ou mais variáveis/colunas.

```{r}
# Ordena empresas pelo lucro líquido (decrescente)
dados %>% 
  arrange(desc(lucro_liquido))
```


## Pipelines de Análise

O dplyr permite criar pipelines (fluxos de operações), nos quais várias 
etapas de manipulação de dados são encadeadas de forma clara e legível.

Esses pipelines são fundamentais para estruturar dados de maneira adequada 
para análises posteriores e criação de visualizações.

Um ponto importante é sempre salvar o resultado final em um novo objeto, 
o que permite reutilizar o resultado em etapas subsequentes. 

Por exemplo, podemos filtrar empresas do setor de Tecnologia, criar a 
variável de margem de lucro e calcular a média da margem em uma 
única sequência:

```{r}
resultado <- dados %>% 
  # filtra apenas empresas de Tecnologia
  filter(setor == "Tecnologia") %>%
  # cria variável margem
  mutate(margem_lucro = lucro_liquido / receita_liquida) %>%  
  # calcula a margem média
  summarize(margem_media = mean(margem_lucro, na.rm = TRUE))

# exibe o resultado
resultado
```


Esse estilo de programação facilita a leitura do código e evita a criação 
de múltiplos objetos intermediários.

Além disso, prepara os dados de forma consistente para a etapa seguinte 
da análise, como visualização com ggplot2.




## Considerações Finais

Com essas funções do dplyr, podemos realizar tarefas comuns de 
manipulação de dados de forma eficiente e legível.

É muito importante dominar essas operações para preparar dados para análise 
e visualização.

As tarefas mais comuns que podemos realizar com as funções do 
pacote dplyr incluem:

- Filtrar linhas/observações com base em condições (`filter`) ou índices 
(`slice`).
- Selecionar colunas/variáveis específicas (`select`).
- Criar novas variáveis ou modificar existentes (`mutate`).
- Agregar resultados por grupos (`group_by` + `summarize`).
- Ordenar e resumir informações (`arrange`).
- Encadear operações em pipelines reprodutíveis usando o operador pipe 
(`%>%`) que preparam os dados para visualização.




